{"version":3,"sources":["reducers/index.js","actions/actionTypes.js","store/configureStore.js","components/Button/Button.jsx","utils/getYouTubeVideoId.js","components/Header/Header.jsx","actions/videoAction.js","utils/loadYouTubeAPI.js","components/Video/YouTube.jsx","utils/timeFormat.js","components/Video/Video.jsx","components/Video/VideoList.jsx","components/MainContent/MainContent.jsx","components/App/App.jsx","serviceWorker.js","index.js","utils/localStorage.js"],"names":["initialState","videos","playingVideo","id","state","type","payload","index","maxId","Math","max","map","video","youtubeId","volume","range","videoId","length","nextVideoIndex","findIndex","previousVideoIndex","splice","defaultState","Button","buttonClass","this","props","className","color","onClick","children","Component","getYouTubeVideoId","url","parseUrl","replace","split","undefined","Header","input","handleInputChange","bind","event","setState","target","value","videosCount","isPlaying","canPlayNextPrev","href","onStopButtonClick","onPlayButtonClick","onPreviousButtonClick","onNextButtonClick","placeholder","onChange","onAddButtonClick","connect","dispatch","api","getYouTubeAPI","Promise","resolve","window","YT","ready","tag","document","createElement","src","firstScriptTag","getElementsByTagName","parentNode","insertBefore","onYouTubeIframeAPIReady","YouTube","container","createRef","handleVideoReady","handleVideoStateChange","onReady","player","data","PlayerState","PLAYING","onPlaying","PAUSED","onPaused","ENDED","onEnded","loadYouTubeAPI","then","Player","current","events","onStateChange","ref","timeFormat","time","hours","floor","minutes","seconds","toString","padStart","Video","videoLoaded","duration","title","interval","setVideoVolume","setVideoRange","removeVideo","onVideoLoaded","onError","trackStatus","setVolume","editVideo","currentTime","getCurrentTime","seekTo","getDuration","getVolume","playVideo","playNextVideo","playerState","getPlayerState","setInterval","clearInterval","prevProps","scrollIntoView","behavior","block","pauseVideo","canMove","vertical","VideoList","list","setList","updateVideos","handle","key","MainContent","App","Boolean","location","hostname","match","store","serializedState","localStorage","getItem","JSON","parse","loadState","createStore","rootReducer","subscribe","throttle","stringify","setItem","saveState","getState","configureStore","ReactDOM","render","getElementById","navigator","serviceWorker","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.60e943cc.chunk.js","sourcesContent":["import * as actionTypes from '../actions/actionTypes'\n\nconst initialState = {\n  videos: [],\n  playingVideo: {\n    id: null\n  }\n}\n\nexport default (state = initialState, { type, payload }) => {\n  let index = null\n\n  switch (type) {\n    case actionTypes.ADD_VIDEO_BY_YOUTUBE_ID:\n      const maxId = Math.max(...state.videos.map(video => video.id), 0)\n      const video = {\n        id: maxId + 1,\n        youtubeId: payload.youtubeId,\n        volume: null,\n        range: [null, null]\n      }\n\n      return {\n        ...state,\n        videos: [...state.videos, video]\n      }\n\n    case actionTypes.ADD_VIDEO:\n      return {\n        ...state,\n        videos: [...state.videos, payload.video]\n      }\n\n    case actionTypes.PLAY_VIDEO:\n      if (state.playingVideo.videoId !== payload.videoId) {\n        return {\n          ...state,\n          playingVideo: {\n            id: payload.videoId\n          }\n        }\n      } else {\n        return state\n      }\n\n    case actionTypes.PLAY_FIRST_VIDEO:\n      if (state.videos.length > 0) {\n        return {\n          ...state,\n          playingVideo: {\n            id: state.videos[0].id\n          }\n        }\n      } else {\n        return state;\n      }\n\n    case actionTypes.PLAY_NEXT_VIDEO:\n      let nextVideoIndex\n      index = state.videos.findIndex(video => video.id === state.playingVideo.id)\n\n      if (index === state.videos.length - 1) {\n        nextVideoIndex = 0\n      } else {\n        nextVideoIndex = index + 1\n      }\n      \n      return {\n        ...state,\n        playingVideo: {\n          id: state.videos[nextVideoIndex].id\n        }\n      }\n\n    case actionTypes.PLAY_PREVIOUS_VIDEO:\n      let previousVideoIndex\n      index = state.videos.findIndex(video => video.id === state.playingVideo.id)\n\n      if (index === 0) {\n        previousVideoIndex = state.videos.length - 1\n      } else {\n        previousVideoIndex = index - 1\n      }\n      \n      return {\n        ...state,\n        playingVideo: {\n          id: state.videos[previousVideoIndex].id\n        }\n      }\n    \n    case actionTypes.UPDATE_VIDEOS:\n      return {\n        ...state,\n        videos: [...payload.videos]\n      }\n\n    case actionTypes.REMOVE_VIDEO:\n      index = state.videos.findIndex(video => video.id === payload.videoId)\n      let playingVideo = null\n\n      if (index !== null) {\n        if (state.playingVideo.id === payload.videoId) {\n          if (state.videos.length <= 1) {\n            playingVideo = {\n              id: null\n            }\n          } else {\n            playingVideo = {\n              id: state.videos[index === state.videos.length - 1 ? 0 : index + 1].id\n            }\n          }\n        }\n\n        const videos = [...state.videos]\n        videos.splice(index, 1)\n\n        if (playingVideo !== null) {\n          return {\n            ...state,\n            videos,\n            playingVideo\n          }\n        } else {\n          return {\n            ...state,\n            videos\n          }\n        }\n      } else {\n        return state\n      }\n\n    case actionTypes.EDIT_VIDEO:\n      index = state.videos.findIndex(video => video.id === payload.video.id)\n\n      if (index !== null) {\n        const videos = [...state.videos]\n        videos.splice(index, 1, payload.video)\n\n        return {\n          ...state,\n          videos\n        }\n      } else {\n        return state\n      }\n\n    default:\n      return state\n  }\n}\n","export const ADD_VIDEO_BY_YOUTUBE_ID = 'ADD_VIDEO_BY_YOUTUBE_ID'\nexport const ADD_VIDEO = 'ADD_VIDEO'\nexport const REMOVE_VIDEO = 'REMOVE_VIDEO'\nexport const EDIT_VIDEO = 'EDIT_VIDEO'\nexport const PLAY_VIDEO = 'PLAY_VIDEO'\nexport const PLAY_FIRST_VIDEO = 'PLAY_FIRST_VIDEO'\nexport const PLAY_NEXT_VIDEO = 'PLAY_NEXT_VIDEO'\nexport const PLAY_PREVIOUS_VIDEO = 'PLAY_PREVIOUS_VIDEO'\nexport const UPDATE_VIDEOS = 'UPDATE_VIDEOS'\n","import { createStore } from 'redux'\nimport rootReducer from '../reducers'\nimport { loadState, saveState } from '../utils/localStorage'\nimport throttle from 'lodash.throttle'\n\nconst defaultState = {\n  videos: [],\n  playingVideo: {\n    id: null\n  }\n}\n\nexport default (initialState) => {\n  if (initialState === undefined) {\n    const state = loadState()\n    initialState = {\n      ...defaultState,\n      ...state\n    }\n  }\n\n  const store = createStore(rootReducer, initialState)\n\n  store.subscribe(throttle(() => {\n    saveState(store.getState())\n  }, 1000))\n\n  return store\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport './Button.scss'\n\nexport class Button extends Component {\n  static propTypes = {\n    color: PropTypes.string,\n    onClick: PropTypes.func,\n    children: PropTypes.node\n  }\n\n  render() {\n    let buttonClass = this.props.className + ' button'\n\n    if (this.props.color) {\n      buttonClass += ` button--${this.props.color}`\n    }\n\n    return (\n      <button className={buttonClass} onClick={this.props.onClick}>\n        {this.props.children}\n      </button>\n    )\n  }\n}\n\nexport default Button\n","export const getYouTubeVideoId = (url) => {\n  let videoId = ''\n  const parseUrl = url.replace(/(>|<)/gi, '').split(/(vi\\/|v=|\\/v\\/|youtu\\.be\\/|\\/embed\\/)/)\n\n  if (parseUrl[2] !== undefined) {\n    videoId = parseUrl[2].split(/[^0-9a-z_-]/i)\n    videoId = videoId[0]\n  } else {\n    videoId = url\n  }\n\n  return videoId\n}\n\nexport default getYouTubeVideoId","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport './Header.scss'\nimport Button from '../Button/Button'\nimport { addVideoByYouTubeId, playFirstVideo, stopVideo, playNextVideo, playPreviousVideo } from '../../actions/videoAction'\n\nexport class Header extends Component {\n  static propTypes = {\n    videos: PropTypes.array,\n    playingVideo: PropTypes.object,\n    onAddButtonClick: PropTypes.func,\n    onPlayButtonClick: PropTypes.func,\n    onStopButtonClick: PropTypes.func,\n    onNextButtonClick: PropTypes.func,\n    onPreviousButtonClick: PropTypes.func\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      input: ''\n    }\n\n    this.handleInputChange = this.handleInputChange.bind(this)\n  }\n\n  handleInputChange(event) {\n    this.setState({\n      input: event.target.value\n    })\n  }\n\n  render() {\n    const videosCount = this.props.videos.length\n    const isPlaying = this.props.playingVideo.id !== null\n    const canPlayNextPrev = isPlaying && videosCount > 1\n\n    return (\n      <header className=\"header\">\n        <div className=\"container\">\n          <a href=\"/\" className=\"header__logo\">YouTube Loop</a>\n          \n          {videosCount > 0 &&\n            <div className=\"header__controls\">\n              {isPlaying ?\n                <Button onClick={this.props.onStopButtonClick}>Stop</Button>\n                :\n                <Button onClick={this.props.onPlayButtonClick}>Play</Button>\n              }\n\n              {canPlayNextPrev &&\n                <>\n                  <Button onClick={this.props.onPreviousButtonClick}>Previous</Button>\n                  <Button onClick={this.props.onNextButtonClick}>Next</Button>\n                </>\n              }\n            </div>\n          }\n\n          <div className=\"header__input-group\">\n            <input type=\"text\" className=\"header__input\"\n              placeholder=\"Enter YouTube URL or Video ID\"\n              value={this.state.input}\n              onChange={this.handleInputChange}\n            />\n            <div className=\"header__input-group-append\">\n              <Button color=\"blue\" onClick={() => this.props.onAddButtonClick(this.state.input)}>Go Loop!</Button>\n            </div>\n          </div>      \n        </div>\n      </header>\n    )\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  videos: state.videos,\n  playingVideo: state.playingVideo\n})\n\nconst mapDispatchToProps = dispatch => ({\n  onAddButtonClick: (input) => {\n    dispatch(addVideoByYouTubeId(input))\n  },\n  onPlayButtonClick: () => {\n    dispatch(playFirstVideo())\n  },\n  onStopButtonClick: () => {\n    dispatch(stopVideo())\n  },\n  onNextButtonClick: () => {\n    dispatch(playNextVideo())\n  },\n  onPreviousButtonClick: () => {\n    dispatch(playPreviousVideo())\n  }\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Header)\n","import * as actionTypes from '../actions/actionTypes'\n// import isYouTubeVideoExists from '../utils/isYouTubeVideoExists'\nimport getYouTubeVideoId from '../utils/getYouTubeVideoId'\n\nexport const addVideoByYouTubeId = (youtubeId) => {\n  const videoId = getYouTubeVideoId(youtubeId)\n\n  return {\n    type: actionTypes.ADD_VIDEO_BY_YOUTUBE_ID,\n    payload: {\n      youtubeId: videoId\n    }\n  }\n\n  // return dispatch => {\n  //   const videoId = getYouTubeVideoId(youtubeId)\n\n  //   isYouTubeVideoExists(videoId).then(isExists => {\n  //     if (isExists) {\n  //       dispatch({\n  //         type: actionTypes.ADD_VIDEO_BY_YOUTUBE_ID,\n  //         payload: {\n  //           youtubeId: videoId\n  //         }\n  //       })\n  //     }\n  //   })\n  // }\n}\n\nexport const addVideo = (video) => {\n  return {\n    type: actionTypes.ADD_VIDEO,\n    payload: {\n      video\n    }\n  }\n}\n\nexport const removeVideo = (videoId) => {\n  return {\n    type: actionTypes.REMOVE_VIDEO,\n    payload: {\n      videoId\n    }\n  }\n}\n\nexport const editVideo = (video) => {\n  return {\n    type: actionTypes.EDIT_VIDEO,\n    payload: {\n      video\n    }\n  }\n}\n\nexport const updateVideos = (videos) => {\n  return {\n    type: actionTypes.UPDATE_VIDEOS,\n    payload: {\n      videos\n    }\n  }\n}\n\nexport const playVideo = (videoId) => {\n  return {\n    type: actionTypes.PLAY_VIDEO,\n    payload: {\n      videoId\n    }\n  }\n}\n\nexport const playFirstVideo = () => {\n  return {\n    type: actionTypes.PLAY_FIRST_VIDEO\n  }\n}\n\nexport const stopVideo = () => {\n  return {\n    type: actionTypes.PLAY_VIDEO,\n    payload: {\n      videoId: null\n    }\n  }\n}\n\nexport const playNextVideo = () => ({\n  type: actionTypes.PLAY_NEXT_VIDEO\n})\n\nexport const playPreviousVideo = () => ({\n  type: actionTypes.PLAY_PREVIOUS_VIDEO\n})\n\n","function loadYouTubeAPI () {\n  return new Promise((resolve) => {\n    if (typeof window.YT === 'object' && typeof window.YT.ready === 'function') {\n      window.YT.ready(() => {\n        resolve(window.YT)\n      })\n\n      return\n    }\n\n    const tag = document.createElement('script')\n    tag.src = 'https://www.youtube.com/iframe_api'\n    const firstScriptTag = document.getElementsByTagName('script')[0]\n    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)\n\n    window.onYouTubeIframeAPIReady = () => {\n      resolve(window.YT)\n    }\n  })\n}\n\nlet api = null\n\nexport default function getYouTubeAPI () {\n  if (!api) {\n    api = loadYouTubeAPI()\n  }\n\n  return api\n}\n","import React, { Component, createRef } from 'react'\nimport PropTypes from 'prop-types'\nimport loadYouTubeAPI from '../../utils/loadYouTubeAPI'\n\nexport class YouTube extends Component {\n  static propTypes = {\n    youtubeId: PropTypes.string,\n    onReady: PropTypes.func,\n    onPlaying: PropTypes.func,\n    onPaused: PropTypes.func,\n    onEnded: PropTypes.func,\n    onError: PropTypes.func,\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.container = createRef()\n    this.handleVideoReady = this.handleVideoReady.bind(this)\n    this.handleVideoStateChange = this.handleVideoStateChange.bind(this)\n  }\n\n  handleVideoReady() {\n    if (typeof this.props.onReady === 'function') {\n      this.props.onReady(this.player)\n    }\n  }\n\n  handleVideoStateChange(event) {\n    if (event.data === this.YT.PlayerState.PLAYING) {\n      if (typeof this.props.onPlaying === 'function') {\n        this.props.onPlaying()\n      }\n    } else if (event.data === this.YT.PlayerState.PAUSED) {\n      if (typeof this.props.onPaused === 'function') {\n        this.props.onPaused()\n      }\n    } else if (event.data === this.YT.PlayerState.ENDED) {\n      if (typeof this.props.onEnded === 'function') {\n        this.props.onEnded()\n      }\n    }\n  }\n\n  componentDidMount() {\n    loadYouTubeAPI().then(YT => {\n      this.YT = YT\n      this.player = new YT.Player(this.container.current, {\n        videoId: this.props.youtubeId,\n        events: {\n          onReady: this.handleVideoReady,\n          onStateChange: this.handleVideoStateChange\n        }\n      })\n    })\n  }\n\n  render() {\n    return (\n      <div ref={this.container}></div>\n    )\n  }\n}\n\nexport default YouTube\n","export default function timeFormat (time) {\n  const hours = Math.floor(time / 3600)\n  const minutes = Math.floor((time - hours * 3600) / 60)\n  const seconds = time - hours * 3600 - minutes * 60\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`\n  } else {\n    return `${minutes}:${seconds.toString().padStart(2, 0)}`\n  }\n}\n","import React, { Component, createRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport './Video.scss'\nimport YouTube from './YouTube'\nimport Button from '../Button/Button'\nimport { removeVideo, editVideo, playVideo, playNextVideo } from '../../actions/videoAction'\nimport timeFormat from '../../utils/timeFormat'\nimport Slider, { Range } from 'rc-slider'\nimport 'rc-slider/assets/index.css'\n\nexport class Video extends Component {\n  static propTypes = {\n    videos: PropTypes.array,\n    video: PropTypes.object,\n    playingVideo: PropTypes.object,\n    removeVideo: PropTypes.func,\n    editVideo: PropTypes.func,\n    playVideo: PropTypes.func,\n    playNextVideo: PropTypes.func\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.container = createRef()\n    this.videoLoaded = false\n    this.player = null\n    this.duration = 0\n    this.title = ''\n    this.interval = null\n\n    this.setVideoVolume = this.setVideoVolume.bind(this)\n    this.setVideoRange = this.setVideoRange.bind(this)\n    this.removeVideo = this.removeVideo.bind(this)\n    this.onVideoLoaded = this.onVideoLoaded.bind(this)\n    this.onPlaying = this.onPlaying.bind(this)\n    this.onEnded = this.onEnded.bind(this)\n    this.onError = this.onError.bind(this)\n    this.trackStatus = this.trackStatus.bind(this)\n  }\n\n  setVideoVolume(volume) {\n    if (this.player) {\n      this.player.setVolume(volume)\n    }\n\n    this.props.editVideo({\n      ...this.props.video,\n      volume\n    })\n  }\n\n  setVideoRange(range) {\n    if (this.player && this.props.playingVideo.id === this.props.video.id) {\n      const currentTime = this.player.getCurrentTime()\n\n      if (range[0] > currentTime) {\n        this.player.seekTo(range[0])\n      }\n    }\n\n    this.props.editVideo({\n      ...this.props.video,\n      range\n    })\n  }\n\n  removeVideo() {\n    this.props.removeVideo(this.props.video.id)\n  }\n\n  onVideoLoaded(player) {\n    const duration = player.getDuration()\n    this.videoLoaded = false\n\n    if (!duration) {\n      this.props.removeVideo(this.props.video.id)\n    } else {\n      this.player = player\n      this.duration = duration\n\n      if (this.props.video.volume === null || this.props.video.range[0] === null || this.props.video.range[1] === null) {\n        this.props.editVideo({\n          ...this.props.video,\n          volume: player.getVolume(),\n          range: [0, duration]\n        })\n      }\n\n      if (this.props.playingVideo.id === this.props.video.id) {\n        player.setVolume(this.props.video.volume)\n        player.seekTo(this.props.video.range[0], true)\n        player.playVideo()\n\n        document.title = this.title + ' - YouTube Loop in React Redux'\n      }\n    }\n\n    this.videoLoaded = true\n  }\n\n  onPlaying() {\n    if (this.props.playingVideo.id !== this.props.video.id) {\n      this.props.playVideo(this.props.video.id)\n    }\n  }\n\n  onEnded() {\n    this.props.playNextVideo()\n  }\n\n  onError() {\n    this.props.removeVideo(this.props.video)\n  }\n\n  trackStatus() {\n    if (this.player) {\n      const currentTime = this.player.getCurrentTime()\n      const playerState = this.player.getPlayerState()\n      const volume = this.player.getVolume()\n\n      if (volume !== this.props.video.volume) {\n        this.setVideoVolume(volume)\n      }\n\n      if (playerState === 1 && currentTime > this.props.video.range[1]) {\n        this.onEnded()\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.interval = setInterval(this.trackStatus, 500)\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval)\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.player && this.props.playingVideo !== prevProps.playingVideo) {\n      if (this.props.playingVideo.id === this.props.video.id) {\n        this.player.setVolume(this.props.video.volume)\n        this.player.seekTo(this.props.video.range[0], true)\n        this.player.playVideo()\n\n        document.title = this.title + ' - YouTube Loop in React Redux'\n        this.container.current.scrollIntoView({\n          behavior: 'smooth',\n          block: 'center'\n        })\n      } else {\n        this.player.pauseVideo()\n        document.title = 'YouTube Loop in React Redux'\n      }\n    }\n  }\n\n  render() {\n    const canMove = this.props.videos.length > 1\n    const isPlaying = this.props.playingVideo.id === this.props.video.id\n    const className = 'video' + (isPlaying ? ' video--active' : '')\n\n    return (\n      <div ref={this.container} className={className}>\n        <div className=\"video__player\">\n          <YouTube youtubeId={this.props.video.youtubeId} onReady={this.onVideoLoaded} onPlaying={this.onPlaying}  onEnded={this.onEnded} onError={this.onError} />\n        </div>\n\n        {this.videoLoaded &&\n          <>\n            <Slider className=\"video__volume-slider\" vertical=\"true\" value={this.props.video.volume} onChange={this.setVideoVolume} />\n            <Range className=\"video__range-slider\" max={this.duration} value={this.props.video.range} onChange={this.setVideoRange} />\n            <div className=\"video__info\">{`Volume: ${this.props.video.volume} — Range: ${timeFormat(this.props.video.range[0])} → ${timeFormat(this.props.video.range[1])}`}</div>\n          </>\n        }\n\n        <div className=\"video__buttons\">\n          {canMove &&\n            <Button className=\"video__move-handle\">Move</Button>\n          }\n          <Button color=\"red\" onClick={this.removeVideo}>Remove Video</Button>\n        </div>\n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n  videos: state.videos,\n  playingVideo: state.playingVideo\n})\n\nconst mapDispatchToProps = dispatch => ({\n  removeVideo: videoId => {\n    dispatch(removeVideo(videoId))\n  },\n  editVideo: video => {\n    dispatch(editVideo(video))\n  },\n  playVideo: videoId => {\n    dispatch(playVideo(videoId))\n  },\n  playNextVideo: () => {\n    dispatch(playNextVideo())\n  }\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Video)\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport { updateVideos } from '../../actions/videoAction'\nimport './VideoList.scss'\nimport { ReactSortable } from 'react-sortablejs'\nimport Video from './Video'\n\nexport class VideoList extends Component {\n  static propTypes = {\n    videos: PropTypes.array,\n    updateVideos: PropTypes.func\n  }\n\n  render() {\n    if (!this.props.videos.length) {\n      return null\n    }\n  \n    return (\n      <ReactSortable tag=\"ul\" list={this.props.videos} setList={this.props.updateVideos} handle=\".video__move-handle\" className=\"video-list\">\n        {this.props.videos.map(video => (\n          <li key={video.id} className=\"video-item\">\n            <Video video={video} />\n          </li>\n        ))}\n      </ReactSortable>\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n  videos: state.videos\n})\n\nconst mapDispatchToProps = dispatch => ({\n  updateVideos: videos => {\n    dispatch(updateVideos(videos))\n  }\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(VideoList)\n","import React, { Component } from 'react'\nimport VideoList from '../Video/VideoList'\n\nexport class MainContent extends Component {\n  render() {\n    return (\n      <div className=\"main\">\n        <div className=\"container\">\n          <VideoList />\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default MainContent\n","import React, { Component } from 'react'\nimport Header from '../Header/Header'\nimport MainContent from '../MainContent/MainContent'\n\nexport class App extends Component {\n  render() {\n    return (\n      <>\n        <Header />\n        <MainContent />\n      </>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport configureStore from './store/configureStore';\nimport './sass/global.scss';\nimport App from './components/App/App';\nimport * as serviceWorker from './serviceWorker';\n\nconst store = configureStore()\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const loadState = () => {\n  try {\n    const serializedState = localStorage.getItem('state')\n\n    if (serializedState === null) {\n      return undefined\n    }\n\n    return JSON.parse(serializedState)\n  } catch {\n    return undefined\n  }\n}\n\nexport const saveState = (state) => {\n  try {\n    const serializedState = JSON.stringify(state)\n    localStorage.setItem('state', serializedState)\n  } catch {}\n}"],"sourceRoot":""}